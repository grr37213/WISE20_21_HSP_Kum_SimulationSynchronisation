Da die Arbeit an der Codebasis nicht auf das HSP-Projekt beschränkt ist, ist eine zukünftige Arbeit an einer Verbesserung der Synchronisation wahrscheinlich. Der aktuelle Stand weist noch einige Probleme und einiges an Optimierungspotenzial auf:
\begin{itemize}
\item Die Sichtrichtung einer Spielerfigur, und somit die grafisch angezeigte Perspektive am Client, wird aktuell noch vom Server bestimmt, ohne dass der Client für die Kamera im 3D-Raum eine eigene Schätzung verwendet. 
Ein Spieler muss so beim Drehen seiner Sicht die Zwei-Wege-Latenz zum Server in Kauf nehmen. Zwar handelt der Server nach dem hier gezeigten Synchronisationsschema mit Gleichzeitigkeit, der Unterschied wird jedoch am Client grafisch merkbar, wenn sich die Perspektive schnell ändert während z.B.~geschossen wird. Projektile sind prinzipiell da wo sie sein sollen, das lokal angezeigte Fadenkreuz u.U.~allerdings nicht. Für einen Shooter ist die Flüssigkeit des Bildes  beim Zielen essentiell.
Dies wäre somit die höchste Priorität für Erweiterungen des klassischen linearen Extrapolationsmodells der Grafik am Client, die lokal anliegenden Eingabeereignisse eigenständig mit einzubeziehen. Problematisch bei der Umsezung ist dort, dass der Server bestimmt, wann der Spieler seine Waffe abfeuert. Er bestimmt damit auch den Rückstoß, der die Blickrichtung ändert.
\item Geräusche, die alle als Reaktion auf ein Ereignis im Spiel auftreten (also vom Server angeordnet werden), wurden im Rahmen des Projekts nicht synchronisiert. Der Grund dafür ist, das aufgrund der Art und Weise, wie diese bisher implementiert sind und eine weitgehende Neuimplementierung des Features notwendig wäre, um auf dem Client zu funktionieren. Das wurde für den Rahmen des Projekts als zu Aufwändig eingeschätzt.
\item Informationen sind aktuell nicht priorisiert. Es wäre jedoch für die gefühlte Latenz von Vorteil, wenn Updates z.B.~zur eigenen Spielfigur in jedem Paket enthalten wären, und nicht nur, wenn diese im Round-Robin Verfahren an der Reihe is. Da aber aktuell der Syncable-Manager nur ein einziges Paket erzeugt, das von der Netzwerkkomponente an alle Clients gesendet wird, muss dort eine signifikante Anpassung erfolgen, um für unterschiedliche Clients unterschiedliche Updates zusammenzustellen. Über ein ähnliches System könnte man außerdem die Genauigkeit von Update-Paketen auf den konkreten Client zuschneiden. So wäre es z.B. vertretbar, bei einem weit entfernten Gegner dessen Sichtrichtung nur mit einer Genauigkeit von 1\,Byte pro Achse zu übertragen.
\item Die bisherige Implementierung erlaubt neben einzelnen Kreierungen und Löschungen von Objekten auch die Einbindung beliebiger Events. Über diese könnte man bisherige bandbreitenintensive Kreierungsbefehle zu Gruppen zusammenfassen, die z.B. mit einem deterministischen Pseudozufallsgenerator auf beiden Maschinen mit minimalem Datenaustausch identische Resultate liefern. Man könnte diese Events außerdem benutzen, um die Updates für eine große Menge an Entitäten zu ersetzen. Dies wäre möglich, indem diese in einer Gruppe zusammengefasst wären und intern deterministisch agieren (z.B Gegner marschieren in Formation). Die übertragenen Events wären dann Befehle, die deterministisch die Aktionen über einen bestimmten Zeitraum bestimmen.
\item Der Client könnte komplexere Vorausberechnungen als die lineare Extrapolation anstellen. So könnte er z.B. temporäre Entitäten erzeugen, die nur solange existieren, bis Serverinformationen über deren Erstellungszeitpunkt den Client erreicht haben. Sie würden dann durch die aktuellen Informationen vom Server ersetzt werden (oder ersatzlos gestrichen, wenn der Server für diesem Zeitpunkt keine Erzeugung einer Entität vorgesehen hat). So könnte der Spieler z.B. lokal ein abgeschossenes Projektil sofort sehen, nicht erst wenn es vom Server bestätigt wurde.
\end{itemize}