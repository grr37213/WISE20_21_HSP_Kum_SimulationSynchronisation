\section{Ausblick}
Da die Arbeit an der Codebasis nicht auf das HSP-Projekt beschränkt ist, ist eine zukünftige Arbeit an einer Verbesserung der Synchronisation wahrscheinlich. Der aktuelle Stand weist noch einige Probleme und einiges an Optimierungspotenzial auf:
\begin{itemize}
\item Clientseitige Vorhersagen zugunsten der Anzeige am Client \cite[ch. 6.2]{gamenetworking00}. Die Sichtrichtung einer Spielerfigur, und somit die grafisch angezeigte Perspektive am Client, wird aktuell noch vom Server bestimmt, ohne dass der Client für die Kamera im 3D-Raum eine eigene Schätzung verwendet. 
Ein Spieler muss so beim Drehen seiner Sicht die Zwei-Wege-Latenz zum Server in Kauf nehmen. Zwar handelt der Server nach dem hier gezeigten Synchronisationsschema mit Gleichzeitigkeit, der Unterschied wird jedoch am Client grafisch merkbar, wenn sich die Perspektive schnell ändert während z.B.~geschossen wird. Projektile sind prinzipiell da wo sie sein sollen, das lokal angezeigte Fadenkreuz u.U.~allerdings nicht. Für einen Shooter ist die Flüssigkeit des Bildes  beim Zielen essentiell.
Dies wäre somit die höchste Priorität für Erweiterungen des klassischen linearen Extrapolationsmodells der Grafik am Client, die lokal anliegenden Eingabeereignisse eigenständig mit einzubeziehen. Problematisch bei der Umsetzung ist dort, dass der Server bestimmt, wann der Spieler seine Waffe abfeuert. Er bestimmt damit auch den Rückstoß, der die Blickrichtung ändert.
\item Geräusche, die alle als Reaktion auf ein Ereignis im Spiel auftreten (also vom Server angeordnet werden), wurden im Rahmen des Projekts nicht synchronisiert. Der Grund dafür ist, das aufgrund der Art und Weise, wie diese bisher implementiert sind und eine weitgehende Neuimplementierung des Features notwendig wäre, um auf dem Client zu funktionieren. Das wurde für den Rahmen des Projekts als zu Aufwändig eingeschätzt.++
\item Informationen sind aktuell nicht priorisiert. Es wäre jedoch für die gefühlte Latenz von Vorteil, wenn Updates z.B.~zur eigenen Spielfigur in jedem Paket enthalten wären, und nicht nur, wenn diese im Round-Robin Verfahren an der Reihe ist. Da aber aktuell der Syncable-Manager nur ein einziges Paket erzeugt, das von der Netzwerkkomponente an alle Clients gesendet wird, muss dort eine signifikante Anpassung erfolgen, um für unterschiedliche Clients unterschiedliche Updates zusammenzustellen. Über ein ähnliches System könnte man außerdem die Genauigkeit von Update-Paketen auf den konkreten Client zuschneiden. So wäre es z.B. vertretbar, bei einem weit entfernten Gegner dessen Sichtrichtung nur mit einer Genauigkeit von 1\,Byte pro Achse zu übertragen.
\item Die bisherige Implementierung erlaubt neben einzelnen Kreierungen und Löschungen von Objekten auch die Einbindung beliebiger Events. Über diese könnte man bisherige bandbreitenintensive Kreierungsbefehle zu Gruppen zusammenfassen, die z.B. mit einem deterministischen Pseudozufallsgenerator auf beiden Maschinen mit minimalem Datenaustausch identische Resultate liefern. Man könnte diese Events außerdem benutzen, um die Updates für eine große Menge an Entitäten zu ersetzen. Dies wäre möglich, indem diese in einer Gruppe zusammengefasst wären und intern deterministisch agieren (z.B Gegner marschieren in Formation). Die übertragenen Events wären dann Befehle, die deterministisch die Aktionen über einen bestimmten Zeitraum bestimmen.
\item Der Client könnte komplexere Vorausberechnungen als die lineare Extrapolation anstellen. So könnte er z.B. temporäre Entitäten erzeugen, die nur solange existieren, bis Serverinformationen über deren Erstellungszeitpunkt den Client erreicht haben. Sie würden dann durch die aktuellen Informationen vom Server ersetzt werden (oder ersatzlos gestrichen, wenn der Server für diesem Zeitpunkt keine Erzeugung einer Entität vorgesehen hat). So könnte der Spieler z.B. lokal ein abgeschossenes Projektil sofort sehen, nicht erst wenn es vom Server bestätigt wurde.
\end{itemize}

\section{Fazit}
Es wurden erfolgreich alle gesetzten Ziele umgesetzt. Das Ergebnis ist ein rudimentärer Multiplayer-Shooter. Es ist eine Simulation von Entitäten welche miteinander und mit den nun mehreren Bedienern interagieren, wobei zwischen den Bedienern eine Netzwerkverbindung existiert. Dadurch entstehende Seiteneffekte konnten entweder komplett ausgeschlossen werden, andere wurden auf ein ausreichendes oder befriedigendes Maß reduziert.\\
Das Ergebnis ist nicht perfekt, der prinzipielle Synchronisationsmechanismus lässt ohne weitere Anforderungen allerdings nicht viel zu wünschen übrig. Das Ergebnis im Sinne der Synchronisation ist funktional, weitere Verbesserungen liegen weiter im Detail.
Wie erwartet und erhofft zeigte das Projekt einige unerwartete Aspekte seines Kernproblems auf. 
Die Wichtigkeit von generellem Applikationsdesign trat durch die Übernahme eines Projektstandes ohne vorherige Synchronisationsaspekte besonders hervor.\\
Die Bearbeitung der Projektaufgabe in Meilensteinen erwies sich als Vorteilhaft, da so die Zeit zum nächsten stabilen Entwicklungsstand verkürzt werden konnte, was ein großer Vorteil zum Testen ist.\\
Die verwendeten Strategien zur Synchronisation, Gleichzeitigkeit und Datenübertragung sind theoretisch interessant, praktisch aber durch die theoretische Durchdringung des Problems vergleichsweise unkompliziert umzusetzen. Der Hauptaufwand zur Umsetzung dieser Strategien liegt in ihrer Peripherie: die Formatierung von Information bezogen auf konkrete Features und Inhalte, Serialisierung, Protokolle, aber auch die designtechnische Anpassung von Features zur Anforderung der Echtzeitsynchronisation. 