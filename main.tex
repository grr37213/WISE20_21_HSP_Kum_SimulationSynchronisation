\documentclass[11pt,twoside,a4paper]{article}

\usepackage{a4wide,amsmath,amssymb}
\usepackage[school, simplified]{pgf-umlcd}
\usetikzlibrary{calc}
\usetikzlibrary{positioning}

% Mann will direkt Umlaute eingeben können statt \"a, \"o, \"u usw.
% Entweder:
\usepackage[utf8]{inputenc}
% oder:
%\usepackage{umlaut}
\usepackage[german]{babel}

\usepackage[style=numeric]{biblatex}
\addbibresource{grr.bib}

\usepackage{textcomp}
\usepackage{graphicx}
\usepackage{subcaption}

\usepackage{hyperref}

\usepackage{tikz}
\usepackage{background}
%uncomment next line to remove "Draft" watermark
%\backgroundsetup{contents={}}


% Trennvorschl"age (in {} einfuegen, wenn nicht automatisch getrennt wird:
% z.B. Authen-ti-ka-tions-sys-tem)
%\hyphenation{}

%\hyphenation{min-des-tens}
%\hyphenation{Kol-li-sions-er-ken-nung}


%-------------------------- Formatsachen --------------------------%

% Bild-, Tabellenunterschriften veraendern:
% Nummer fett, kleinerer Text fuer Bildunterschrift
%\usepackage[bf,small]{caption}


%\usepackage{mathpazo}  % -- Palatino als Zeichensatz -- einfach diese
					   % Zeile auskommentieren, falls nicht installiert
%\usepackage{mathptmx}  % -- Times als Zeichensatz

% Zum Unterscheiden von Entwurfs- und endgueltiger Fassung
%\usepackage{draftcopy}
%\draftcopySetGrey{0.90}   %   90% = sehr helles Grau
%\draftcopyName{ENTWURF}{155}   % statt ``DRAFT''
%\draftcopySetScale{1}

%--------------- Zeilen- und Absatzabstaende ----------------------%
%\setlength{\parindent}{0em}
%\setlength{\parskip}{\medskipamount}    % Abstand zwischen Abs"atzen

\newcommand{\obj}{\operatorname{OBJ}}
\newcommand{\pos}{\operatorname{pos}}
\newcommand{\rot}{\operatorname{rot}}
\newcommand{\gridsize}{s_{\mathit{grid}}}
\newcommand{\tometer}{\mathit{meter}}
\newcommand{\calAABB}{\mathcal{AABB}}
\newcommand{\AABB}{\mathit{AABB}}
\newcommand{\qb}{\operatorname{QB}}


\begin{document}

\title{HSP-Projektarbeit im Master Informatik \\
\small Echtzeitsynchronisation von Simulationen mit Fokus auf die Verwendung in Videospielen}
\author{Robert Graf, Lukas Hermann\\
%  (\texttt{fridolw@in.tum.de})\\[5mm]
%  Seminar "`Internetrouting"' , \\
  Ostbayerische Technische Hochschule Regensburg\\
  \\
  Projektbetreuung: Prof. Dr. Markus Kucera
}
  
\date{WS\, 2019/2020 (Version vom \today)}

\maketitle

\newpage
\tableofcontents
\newpage

\input{abstract.tex}

\section{Einleitung}
\input{introduction.tex}

\section{Beschreibung der konkreten Simulationsanwendung}
Die verwendete Simulationsanwendung ist ein rudimentäres 3D-Shooter-Videospiel. Ein Spieler kann dabei in einem Terrain auf Gegnerfiguren schießen, diese beschädigen und wird dabei durch Punkte entlohnt. Diese einfache Anwendung beinhält bereits alle Kernaspekte einer Simulation im Kontext dieser Arbeit:
\begin{itemize}
\item Die Simulation ist gezeitet und läuft in einer bestimmten Rate zur Realzeit. Diese Rate soll meist $1$ sein, bei der physikalische Vorgänge dieselbe Geschwindigkeit wie in der Realität annehmen. Die Simulation besitzt dadurch ihre eigen Simulationszeitbasis.
\item Verschiedene Arten von zu simulierenden Entitäten in einem Simulierten Raum (Gegner, Spieler, Projektile) mit unterschiedlichem Verhalten/unterschiedlicher Physik.
\item Interaktionen zwischen Entitäten (Kollisionen, Anti-Clipping)
\item Einflüsse durch Bediener/Spieler (Bewegung der Spielerfigur, Erzeugung von Projektilen)
\item Grafische Ausgabe in Echtzeit zu einer dreidimensionalen Perspektive
\end{itemize}

Die Simulation von Simulationsinhalten erfolgt in Schritten, in denen ein Inhalt von einem bestehenden Zustand auf einen Zustand zu fortgeschrittener Simulationszeit verändert wird. Ein solcher Zeitschritt wird als Tick bezeichnet.\\
%%TODO cite Appendix
Die Anzeige der Simulation erfolgt durch Inter-/Extrapolation der bekannten Zustände von Simulationsinhalten zu einem bestimmten Simulationszeitpunkt. Die Anzeige führt dabei keine Änderungen auf den Simulationsinhalten durch. Wir bezeichnen den Prozess sowie sein Ergebnis als Frame.
%%TODO cite Appendix
Die Framerate kann ungleich der Tickrate sein, um unabhängig von den Fähigkeiten des Anzeigesystems eine flüssiges Bild zu generieren. Da in einem Frame keine Simulationsinhalte geändert werden, sind die Simulationinhalte komplett unabhängig zur Anzeige.\\

In vielen kommerziellen Produkten in der Videospielbranche wird diese Trennung nicht sauber vollzogen.\\
Es folgen Inkonsistenzen in der Simulation in Abhängigkeit der Framerate.
%%TODO Beispiel Skyrim fliegende Mammuts
Es existiert dort dann meist eine maximale Framerate.
Dieser Umstand scheint die Problematik mitzuführen, dass viele Videospielehersteller, vor allem im Konsolenbereich, Frameraten immer weiter nach unten limitieren, um ihre Produkte umzusetzen, was die Qualität erheblich senkt 
(entgegen der Meinung ihrer Marketingabteilungen
%%TODO cite 'more cinematic shitstorm'
) und dazu führt dass Benutzer ihre u.U.~teure, fähige Hardware nicht ausnutzen können und sich mit schlechter Bildqualität zufrieden geben müssen.
Es scheint eine grundsätzliche Designentscheidung zu sein, die in einigen kommerziell genutzten Videospielengines fehlt.\\

Die beschriebene Anwendung funktioniert zu Beginn des Projektes lokal mit einem Benutzer. Es ist Ziel dieser Arbeit möglichst volle Funktionalität auf mehrere Benutzer, welche mit einer Netzwerkverbindung verbunden sind zu erweitern und dabei möglichst wenige negative Seiteneffekte zu erzeugen.

\section{Hergang}
\input{proceedings.tex}

\section{Entwicklung der Softwarearchitektur einer synchronisierbaren Simulation}
Durch die Übernahme des Status-Quo eines bestehenden Projektes bestehen Probleme im Design der Applikation, die eine Umsetzung einer Synchronisation zunächst verhindern. Es wird daher eine Überarbeitung der generellen Architektur der Applikation gefordert.\\
Grundsätzlich wird angenommen, dass eine Echtzeitsynchronisation ständige Kommunikation zwischen beteiligten Knoten erfordert.
Information über aktiv simulierte Simulationsinhalte sollen so oft wie möglich wiederholt versendet werden, um die auf dem Remote verfügbare Information so aktuell wie möglich zu halten. Dabei müssen Einschränkungen der Übertragungsmedien und -methoden respektiert werden.\\



%%TODO clarify and/or find source

\subsection{Übertragungsmethoden}
Zur Echtzeitsynchronisation wird angenommen, dass Aktualisierungsinformation zur Synchronisation der verbundenen Simulationsapplikationen regelmäßig ausgetauscht wird, d.h.~Information wird ständig übertragen, um einen möglichst aktuellen Stand auf dem Remote herzustellen. Ein Remote ist dabei niemals perfekt synchron, es kann nur die Zeit zum letzten bekannten validen Stand möglichst kurz gehalten werden.

Zur Entwicklung einer optimalen Übertragung werden verschiedene Aspekte in die Überlegung mit einbezogen:

\subsubsection{Transportschicht}
Es stehen zwei Protokolle der ISO-OSI Transportschicht zur Verfügung:
\begin{enumerate}
\item TCP, mit den relevanten Eigenschaften der Verbindungsorientiertheit, Erhaltung der Reihenfolge und Übertragungsversicherung als Abstraktion einer Stream-Datenstruktur\\
	Die Eigenschaften von TCP beinhalten für Echtzeitanwendungen jedoch gefährliche vorhersehbare Nachteile:\\
	Bei spontanem Paketverlust fallen Wartezeiten durch Sendewiederholung an, welche weiteren Informationserhalt über den TCP-Socket blockiert.\\
Ein Beispiel der unvorteilhaften Verwendung von TCP im Bereich von Videospielen ist das äußerst erfolgreiche und bekannte Spiel Minecraft von Mojang. Hier äußern sich Netzwerkverzögerungen (Lags) durch einen Stillstand der Spielabläufe, der sich über Sekunden ziehen kann und anschließendes Aufholen der Simulationszeit im Zeitraffer. Manch ein unverdientes Game Over kann daher von einem Gegner verursacht werden, der in der Zeit des Stillstandes Angriffe auf den Spieler im TCP-Puffer ansammelt, auf die der Spieler nicht reagieren kann. Dieser Umstand ist umso mehr Schade, wenn das verzögernde Paket zu dieser Zeit bereits schon, aufgrund von Echtzeitanforderungen, irrelevant ist, bzw. bereits ein aktuelleres im Puffer liegt.\\
%%TODO cite
Die Verwendung von TCP für echtzeitrelevante Information ist daher nur ratsam, wenn die zu übertragende Information die von TCP erhaltenen Eigenschaften von Reihenfolge und Übertragungssicherheit auch tatsächlich fordert. In diesem Fall muss ein Protokoll, welches diese Eigenschaften implementiert nicht im Rahmen von UDP selbst umgesetzt werden.\\
Durch seine Verbindungsorientiertheit bietet sich TCP ebenfalls für die Verbindungskontrolle an, da der Verbindungsstatus, z.B.~ bei abgebrochenen Verbindungen leicht erkannt werden können. Des weiteren lassen sich auf der Basis einer TCP-Verbindung leicht eigene sequenzielle Protokolle implementieren, z.B. um eine Verbindung zweier Applikationen in der Applikationsschicht herzustellen.
\item UDP, mit den relevaten Eigenschaften der anforderungslosen Übertragung von Datenpaketen\\
	Im Videospielbereich sehen wir hauptsächlich UDP verwendet, höchstwahrscheinlich
	da die meisten Informationen im Rahmen der Echtzeitsynchronisation von Videospielen die unter TCP beschriebenen Eigenschaften nicht zwingend fordert.
\end{enumerate}

Im Folgenden werden diese Protokolle für hier enthaltenen Verwendungszwecke in Betracht gezogen und entsprechend ihrer Eigenschaften gewählt.

\subsubsection{Informationsformat}

Es werden prinzipiell zwei grundlegende Formate von Information betrachtet.
\begin{enumerate}
\item Statusinformation\\
In der Simulation liegt die Information zu ihren Inhalten in Form von gezeiteten Stati vor, d.h. ein Zustand eines Interesses zu einem bestimmten Zeitpunkt, sei dieser Real- oder Simulationszeit. \\
So ist ein Projektil z.B.~durch Position und Geschwindigkeit zu einem Simulationszeitpunkt dargestellt, welche nach entsprechenden physikalischen Gesetzen aktualisiert werden kann.\\
Die wohl interessanteste Eigenschaft von Statusinformation im Rahmen der Synchronisierung ist bei Mitführung des Zeitpunktes der Validität der Information die inhärente Redundanz bei wiederholter Übertragung durch simples überschreiben älterer Stati, welche die Übertragung sehr robust macht.
Das präferierte Übertragungsprotokoll für diese Art Information ist UDP, da es dessen Eigenschaftsprofil entspricht.
Wir erkennen jedoch auch, dass das Optimierungspotential von Synchronisationsprotokollen bei der Verwendung von roher Statusinformation beschränkt ist. Bei vielen Entitäten, oder bei komplexen Entitäten wird der benötigte Sendungsumfang unter Umständen zu groß.
Zum Beispiel werden beim Schießen einer Schrotflinte in der Simulation theoretisch zigfach Projektile frei, welche dann simuliert und synchronisiert werden sollen.
Unter der Verwendung von Statusinformation zur Synchronisation dieser Projektile steigt die Menge der zur Synchronisation versendeten Daten mindestens linear.\\
Dieser Umstand kann nur durch eine abstraktere Behandlung von mehreren Projektilen in der Simulation, beispielsweise als Schwarm, oder eine abstraktere Übertragungsmethode abgeschwächt werden.
\item Aktualisierungsinformation\\
beschreibt die Änderung eines Zustands zu einem bestimmten Zeitpunkt. Diese umfassen meist codierte Anweisungen oder arithmetische Differenzen, welche auf den Status am Empfänger aufgerechnet werden.\\
Ein Problem mit Änderungsinformation besteht, wenn diese keine kommutativen und/oder assoziativen Eigenschaften beinhaltet und so sowohl die Übertragungsreihenfolge als auch die Übertragung selbst abgesichert sein muss, um die Äquivalenz des am Empfänger ermittelten Simulationsstatus herzustellen. In diesem Fall ist das präferierte Übertragungsprotokoll TCP, da dieses die so geforderten Eigenschaften mitbringt. Ist die Reihenfolge oder das Fehlen der Information am Empfänger allerdings nicht kritisch kann auch hierfür einfach UDP verwendet werden. Es ist jedoch hier essentiell eine Analyse zu vollziehen, da sonst zu synchronisierende Simulationsstati sich plötlich desynchronisieren können.
\item Initialisierungsinformation\\
Beim Verbindungsaufbau müssen ebenfalls schon Informationen ausgetauscht werden. Dabei sind einige Verbindungsorganisatorisch, andere können allerdings auch die Simulation direkt betreffen. 
Derzeitig fallen nur organisatorische Informationen an, sämtliche die Simulation betreffenden Initialisierungsdaten, sowie Ressourcen, sind an beiden Enden der Verbindung statisch bekannt.
TCP wird für den initialen Austausch von Informationen zwischen den beteiligten Applikationen verwendet. Zu den Aufgaben hier zählen:
\begin{itemize}
\item Filterung von Fremdverbindungen durch eine applikationsspezifische Begrüßung
\item Identifikation von Servern und Clients (wir verzichten im Rahme dieser Arbeit auf Sicherheitsaspekte, wie z.B. saubere Authentifizierung, etc.)
\item Die Übermittlung der Adressierung von UDP-Sockeln der jeweiligen Knoten.
\item Die Übertragung von Synchronisationsinformation, welche nicht dem herkömmlichen Profil von übertragenen Simulationsstati entspricht. Die konkrete Verwendung von TCP in diesem Kontext wird in Abschnitt %%TODO ref
genauer beschrieben und begründet.
\end{itemize}
\end{enumerate}

\subsubsection{Generelle Präferenz}
Die Übertragung von Statusinformation via UDP wird unter den gegebenen Anforderungen auf Grund seiner Robustheit und Einfachheit als präferiert angesehen. Es wird zunächst versucht so viele Features wie möglich über diese Übertragungsstrategie abzubilden.\\
Die Verwendung von Änderungsinformation wird sich für andere Verwendungszwecke vorbehalten, hauptsächlich, da das Optimierungspotential hier höher scheint.


\subsection{Anmerkungen zur übernommenen Codebasis}
Durch die Hinzunahme von Echtzeitsynchronisationsfähigkeit als Anforderung an die Applikation werden im Design der übernommenen Codebasis schnell Verletzungen des \textit{Separation of Corcerns} Prinzips ersichtlich.\\
Das Fehlen von Anforderungen hinsichtlich mehrerer Benutzer und Fernsteuerung von Simulationsinhalten erlaubt in der übernommenen Codebasis für kurze Implementierungswege durch viele $1:1$ Beziehungen, welche sich hier weiter als kritisch erweisen. Belange(Concerns) waren über besagte $1:1$ Beziehungen daher oft nicht sauber für den Zweck einer Synchronisation abgegrenzt, Komponenten sind unnötig engmaschig vernetzt. Viele Basisaspekte der Simulationsengine werden daher komplett neu erdacht und designed, was den Hauptanteil der im Projekt aufgebrachten Zeit ausmacht.\\
Auch viele periphere Features müssen überarbeitet werden, oder es droht der Verlust des Features. Dabei werden oft Neurealisierungen des Features genauso Umfangreich wie seine Entfernung eingeschätzt.
Die konkreten vollzogenen Änderungen sind oft umfangreich und weitreichend, ihre Begründung allerdings komplex, detailreich und werden daher für diesen Bericht nicht als geeignet oder interessant eingeschätzt.\\
Wir erfahren so die Grundlegenheit, Kritikalität und Komplexität einer Anforderungsänderung in Punkten Synchronisation.
Es bestätigt, dass das frühzeitige Miteinbeziehen einer Synchronisations- oder Echtzeitanforderung in Softwareprojekten ratsam ist.


\subsection{Applikationsdesign}
Der Umbau der übernommenen Codebasis erfolgt sukzessiv und iterativ nach Bedarf. 
So werden die in Abschnitt~\ref{sec:proceedings} beschriebenen Meilensteine abgearbeitet.\\
Es werden die letztendlichen Ergebnisse des Umbaus der allgemeinen Softwarearchitektur präsentiert, welche alle einbezogenen Aspekte beinhalten:

Im Rahmen des Umbaus werden mehrere für das Design zentrale Abstraktionen angelegt.
Diese bestehen aus Abstraktionen aus der übernommenen Codebasis, Neukreationen, und Isolationen von Belangen aus bereits bestehenden Abstraktionen. Im Sinn dieses Berichts wird sich in der folgenden Liste auf die relevanten Abstraktionen im Rahmen der Synchronisation beschränkt.

\begin{enumerate}
\item Simulation\\
Die Simulation ist der Backend-Kern der Applikation. Hier sitzen Simulationsinhalte und werden der Simulationszeit ausgesetzt. Die Abstraktion dient auch der Möglichkeit der Umsetzung verschiedener Objektive der gesamten Simulation, sei dies ein Testzweck oder die Umsetzung eines Produkts, wie der Shooter-Applikation.
\item User\\
Der User ist die Repräsentation eines (menschlichen) Bedieners und regelt somit bestimmte Ein- und Ausgabevektoren der Simulation, so wie sämtliche Ressourcen die zur Ermittlung oder Verarbeitung dieser benötigt werden.
\item Entitäten\\
Sind Simulationsinhalte. Eine Entität beschreibt ein "Etwas", das simuliert werden soll, im konkreten etwas, welches sich im simulierten Raum befindet. Eine Entität beschreibt ihr Verhalten in Abhängigkeit zur Simulationszeit und kann Interaktionen mit anderen Entitäten eingehen. Entitäten werden genauer im Anhang~\ref{sec:entity} erklärt.
\item Benutzerentität/Spielerfigur\\
Eine spezielle Entität, welche als Avatar für den Benutzer in der simulierten Welt dient. Diese Spezialisierung ist essentiell im Bereich von Videospielen, um dem Spieler Zugang zur simulierten Welt zu geben indem die Spielerfigur Interaktionen verursacht. Die Benutzerentität implementiert dabei im Entitätsverhalten die Reaktion auf Eingabeparameter eines Benutzers und ermöglicht den Erhalt einer Perspektive auf einen simulierten Raum, v.A.~für Zwecke des Renderings aus der dreidimensionalen Perspektive der Figur.
\item OS-Zugang\\
Enthält Zugriff und Schnittstellen zu Ressourcen des Betriebssystems, dem Fenster, Ereignisquelle, Lautsprecher, etc.
\item Ereignisverarbeitung\\
Über Bibliotheken werden Betriebssystemressourcen angefordert, wie z.B. ein Fenster. Ein Fenster ist in der Lage, Eingaben von Eingabegeräten (Tastatur, Maus, etc.) und Fenster bezogene Information (Größenänderung, Status des Fokus, etc.) in Form sog.~Ereignisse(eng. \textit{events}) zu liefern. Verhalten des Fensters sind größtenteils von den verwendeten Bibliotheken gekapselt, jedoch erfordern bestimmte Aspekte eine Reaktion weiterer Komponenten (z.B. beim Schließen des Fensters sollen Ressourcen freigegeben werden, Simulation geschlossen werden, etc.).
Weiter sollen natürlich Eingaben für die Verwendung als Steuerung der Simulation verwendet werden. Die Ereignisverarbeitung beschreibt dabei ein System, welches die Eingaben in einen von der Simulation,bzw.~von Benutzerentitäten interpretierbaren Status umwandelt.
\item 3D Renderer der Simulation\\
Die Aufgabe des Renderers ist es, ein Bild des simulierten Raums aus einer bestimmte Perspektive zu erstellen und auf ein Fenster des Betriebssystems zu übertragen.
Ein Renderer greift lesend in viele Aspekte der Simulation ein, um die Informationen für seine Aufgabe zu erhalten.
\item Applikationskopf\\
Als zentrale Organisationsstruktur des Programms ist es die Aufgabe des Applikationskopfes, den Programmablauf zu Regeln. Das Programm besteht in seinem Kern aus einer Schleife, in der wiederholt andere genannte Subkomponenten ihre Verarbeitungsschritte durchführen. Der Applikationskopf dient dabei als Abstraktion für das Verhalten der Gesamtapplikation. So können verschiedene Verwendungszwecke, bzw. Arten der Gesamtapplikation (Standardprogramm, Fernbedienung, Simulation mit Fernbedienungsempfänger, etc.) realisiert werden.
\end{enumerate}

\begin{figure}

\centering
\resizebox{.9\linewidth}{!}{
\begin{tikzpicture}[thick,scale=1, every node/.style={scale=1}]
\begin{package}{Applikation}
\begin{class}{Applikationskopf}{0,0}
\end{class}
\begin{class}{Renderer}{-3, -3}
\end{class}
\begin{class}{Simulation}{4,-1}
\end{class}
\begin{class}{Ereignisverarbeitung}{-9,-2}
\end{class}
\begin{class}{OS/Window}{-9,-3}
\end{class}
\begin{class}{Entity}{9, -2}
\end{class}
\begin{class}{User}{-4,-1}
\end{class}
\begin{class}{Userentity}{9,-3}
\inherit{Entity}
\end{class}


\aggregation{Applikationskopf}{1}{}{Simulation}
\aggregation{Applikationskopf}{1}{}{User}
\composition{User}{1}{}{Ereignisverarbeitung}{j1}{}
\aggregation{Simulation}{1}{}{Userentity}{N}{}
\composition{User}{1}{}{OS/Window}{1}{}
\aggregation{Simulation}{1..*}{}{Entity}
\association{Simulation}{1}{}{User}{}{N}
\association{Renderer}{1}{}{OS/Window}{1}{}
\association{Renderer}{N}{}{Simulation}{1}{}
\aggregation{User}{1}{}{Renderer}

\end{package}
%%\draw [dashed] (0,1) -- (0,-5);
\end{tikzpicture}
}
\caption{UML-Klassendiagramm zur Veranschaulichung der hier umgesetzten Architektur.}
\label{fig:new_architecture}
\end{figure}

Die Abbildung~\ref{fig:new_architecture} zeigt die neugewonnene Architektur anhand der Abstraktionen und ihrer Abhängigkeiten untereinander.

Die Existenz dieser konkretisierten Abstraktionen erlauben uns nun die Umsetzung benötigter Features, die vorher so nicht möglich waren:
\begin{itemize}
\item Dislokation eines Benutzers hinter eine Netzwerkverbindung\\
	Durch die Abstraktion eines Benutzers kann dieser für den kontext einer Lokalen oder Remoteverbindung abstrahiert werden.
\item Behandlung mehrerer Benutzer, mehrerer Eingaben\\
	Vor allem die isolierte Abstraktion der Simulation kann nun auf die Fähigkeit zur Behandlung meherer Benutzer erweitert werden.
\item Optionalität einer grafischen Ausgabe\\
	Durch die Trennung der Perspektive von der Spielerfigur kann nun entschieden werden, ob ein 3D-Renderer überhaupt initialisiert wird. Das ist vor allem für die Anforderung mehrerer Benutzer von Interesse, weil so theoretisch beliebig viele Perspektiven der existierenden Spielerfiguren gerendert werden können. Die grafik ist dadurch nicht nur flexibler, es macht auch die Implementierung eines dedizierten Servers (ohne lokalen Benutzer) möglich.
\item Unterschiedliche grafische Ausgabeperspektiven\\
	Es ist möglich einer graphischen Ausgabe unterschiedliche Perspektiven zur Anzeige zuzuweisen. Vorausgesetzt mehrere aktive Simulationsinhalte sind dazu fähig eine Perspektive zu spezifizieren (derzeitig nur eine Art von Spielerfigur)
\item Kontrolle von schreibendem Zugriff eines auf Simulationsinhalte (für Clients)\\
Die Unterscheidung der Simulation und der Simulationsinhalte/Entitäten ermöglicht die Übertragung der Simulationsinhalte außerhalb des konkreten Kontextes der aktiven Simulation. So müssen Simulationsinhalte nicht von ausschließlich der Simulation aktualisiert werden, sondern dies kann z.B. über eine Netzwerkverbindung geschehen.
\item Stabiler Applikationsstart unabhängig zu einer Simulation (Öffnen des Fensters, Mausverhalten)\\
	Durch die Abgrenzung von Belangen vor allem hinsichtlich benötigter Systemressourcen von der Simulationsanwendung ermöglicht benutzerdefinierte Einstellungen der Applikation durch Konfiguration, Eingabeparameter.
	So können verschiedene Applikationskontexte realisiert werden, z.B.~als Client, als Server, nur Lokal, Fernsteuerung, etc..
	Des Weiteren kann so einfacher das Laden von benötigten Applikationsressourcen, besonders im grafischen Kontext gesteuert werden.
\end{itemize}

Wie diese nun ermöglichten Features im Weiteren zur Umsetzung der Projektziele verwendet werden werden in den folgenden Abschnitten erläutert.

\input{remotecontrol.tex}

\input{sync.tex}

\section{Zusammenfassung}
\input{summary.tex}

\newpage

\printbibliography
\newpage

\appendix
\input{spec_main.tex}


%\bibliographystyle{hieeetr}
%\addcontentsline{toc}{chapter}{Bibliography}
%\bibliography{grr.bib}
%\begin{thebibliography}{12}
%\bibitem[HaKT1 98]{HaKT1 98} \footnote{In die 
%Bibliographie sollte s"amtliche benutzte Literatur 
%rein, auch nicht beim eigenen Vortrag angegebene, aber benutzte Papiere 
%und B\"ucher. Gleichzeitig sollte aber alles in der Literaturliste angegebene
%mindestens einmal im Artikel zitiert werden, sonst nicht auflisten.}
        %Michael Harkavy, J. D. Tygar, Hiroaki Kikuchi: {\sl Multi-round 
        %Anonymous Auction Protocols}; 1st IEEE Workshop on Dependable and 
        %Real-Time E-Commerce Systems, 1998.

%\input{main_bibliography.tex}
%\input{grr_bibliography.tex}
%\input{hel_bibliography.tex}
%\end{thebibliography}

\end{document}





